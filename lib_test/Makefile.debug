# Makefile to build and run the test files in a variety of ways

P4INC := -I `ocamlfind query type-conv` -I ../lib pa_type_conv.cmo pa_dyntype.cma
BINC := -I ../lib pa_dyntype.cma
NINC := -I ../lib pa_dyntype.cmx

PACKS= -package unix,oUnit

# p_% prints out the process ML file to stdout
.PHONY: p_%
p_%:
	camlp4o $(P4INC) -parser -printer o $*.ml

# top_% makes a top-level for the ML file
top_%: pc_%
	ocamlfind ocamlmktop $(PACKS) -linkpkg -o $@ $(BINC) pc_$*.cmo

# pc_% compiles it via a temporary ML file (pc_%.ml) so that locations in generated code can be
# seen in error messages as a debugging aid
pc_%: %.ml
	camlp4o $(P4INC) -printer o $*.ml > $@.ml
	ocamlfind ocamlc -verbose -linkpkg -g -annot -o $@ $(PACKS) $(BINC) $@.ml

# pr_% compiles and runs the code via the intermediate ML file
pr_%: pc_%
	@./$<

# c_% compiles the ML file directly by invoking camlp4 as -pp (how it is used in production)
c_%: %.ml
	ocamlfind ocamlc -verbose -o $@ -linkpkg -g $(PACKS) \
	  -pp "camlp4o $(P4INC) " $(BINC) $*.ml

nc_%: %.ml
	ocamlfind ocamlopt -o $@ -linkpkg $(PACKS) \
	  -pp "camlp4o $(P4INC) " $(NINC).cmx $*.ml

# r_% runs the executable generated by directly compiling with the p4 extension
r_%: c_%
	@./$<

# i_% displays the inferred OCaml interface of the generated functions
.PHONY: i_%
i_%: %.ml
	ocamlfind ocamlc -i -verbose -linkpkg -g $(PACKS) \
	  -pp "camlp4o $(P4INC)" $(BINC) $*.ml

# pi_% prints to a temporary file and then displays the Ocaml interface
pi_%: %.ml
	camlp4o $(P4INC) -parser -printer o $*.ml > $@.ml
	ocamlfind ocamlc -verbose -i -linkpkg -g $(PACKS) $(BINC) $@.ml
	
.PHONY: clean
clean:
	rm -f pc_* c_* pi_* *.cmo *.cma *.db *.cmi top_* pc_*
